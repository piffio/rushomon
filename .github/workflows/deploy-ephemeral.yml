name: Deploy Ephemeral Environment

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, labeled, unlabeled]
    # Only trigger if code files change (skip docs-only changes)
    paths:
      - 'src/**'
      - 'tests/**'
      - 'Cargo.toml'
      - 'Cargo.lock'
      - 'wrangler.example.toml'
      - 'migrations/**'
      - 'frontend/**'
      - '.github/workflows/deploy-ephemeral.yml'
      - '.github/workflows/cleanup-ephemeral.yml'

permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: ephemeral-${{ github.head_ref || github.ref }}
  cancel-in-progress: true

jobs:
  deploy-ephemeral:
    name: Deploy to Ephemeral Environment
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment: ephemeral
    # Deploy only if:
    # 1. PR is from the same repo (not a fork) OR it's a push event
    # 2. PR is not in draft state
    # 3. PR does not have 'skip-preview' label
    if: |
      (github.event_name == 'pull_request' &&
       github.event.pull_request.head.repo.full_name == github.repository &&
       github.event.pull_request.draft == false &&
       !contains(github.event.pull_request.labels.*.name, 'skip-preview')) ||
      github.event_name == 'push'

    steps:
      - uses: actions/checkout@v4

      - name: Determine PR Number
        id: pr_number
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          else
            # For push events on non-main branches, extract from branch name or use commit SHA
            PR_NUM=$(echo "${{ github.ref }}" | sed 's|refs/heads/||' | grep -oE '[0-9]+' | head -1)
            if [ -z "$PR_NUM" ]; then
              PR_NUM=$(echo "${{ github.sha }}" | cut -c1-7)
            fi
            echo "pr_number=$PR_NUM" >> $GITHUB_OUTPUT
          fi

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache Rust
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: '.'

      - name: Cache npm
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install wrangler and worker-build
        run: |
          npm install -g wrangler
          cargo install -q worker-build

      - name: Build Worker
        run: worker-build --release

      - name: Create D1 Database
        id: create_d1
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
        run: |
          DB_NAME="rushomon-pr-$PR_NUMBER"

          # Check if database already exists
          echo "Checking if database '$DB_NAME' already exists..."
          LIST_RESPONSE=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/d1/database" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN")

          DB_ID=$(echo "$LIST_RESPONSE" | jq -r ".result[] | select(.name == \"$DB_NAME\") | .uuid // .id" | head -1)

          if [ -n "$DB_ID" ]; then
            echo "âœ… Database already exists: $DB_NAME (ID: $DB_ID)"
          else
            echo "ðŸ†• Creating new database: $DB_NAME"

            # Create database via Cloudflare API
            RESPONSE=$(curl -s -X POST \
              "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/d1/database" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"name\": \"$DB_NAME\"}")

            DB_ID=$(echo "$RESPONSE" | jq -r '.result.uuid // .result.id // empty')

            if [ -z "$DB_ID" ]; then
              echo "âŒ Failed to create D1 database"
              echo "Response: $RESPONSE"
              exit 1
            fi

            echo "âœ… Created database: $DB_NAME (ID: $DB_ID)"
          fi

          echo "database_id=$DB_ID" >> $GITHUB_OUTPUT
          echo "database_name=$DB_NAME" >> $GITHUB_OUTPUT

      - name: Create KV Namespace
        id: create_kv
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
        run: |
          KV_NAME="URL_MAPPINGS_pr_$PR_NUMBER"

          # Check if KV namespace already exists
          echo "Checking if KV namespace '$KV_NAME' already exists..."
          LIST_RESPONSE=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/storage/kv/namespaces" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN")

          KV_ID=$(echo "$LIST_RESPONSE" | jq -r ".result[] | select(.title == \"$KV_NAME\") | .id" | head -1)

          if [ -n "$KV_ID" ]; then
            echo "âœ… KV namespace already exists: $KV_NAME (ID: $KV_ID)"
          else
            echo "ðŸ†• Creating new KV namespace: $KV_NAME"

            # Create KV namespace via Cloudflare API
            RESPONSE=$(curl -s -X POST \
              "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/storage/kv/namespaces" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"title\": \"$KV_NAME\"}")

            KV_ID=$(echo "$RESPONSE" | jq -r '.result.id // empty')

            if [ -z "$KV_ID" ]; then
              echo "âŒ Failed to create KV namespace"
              echo "Response: $RESPONSE"
              exit 1
            fi

            echo "âœ… Created KV namespace: $KV_NAME (ID: $KV_ID)"
          fi

          echo "kv_id=$KV_ID" >> $GITHUB_OUTPUT
          echo "kv_name=$KV_NAME" >> $GITHUB_OUTPUT

      - name: Create Ephemeral wrangler.toml
        env:
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
          DB_ID: ${{ steps.create_d1.outputs.database_id }}
          KV_ID: ${{ steps.create_kv.outputs.kv_id }}
          WORKERS_DOMAIN: ${{ secrets.WORKERS_DOMAIN }}
        run: |
          cat > wrangler.ephemeral.toml << 'EOF'
          name = "rushomon-pr-${{ env.PR_NUMBER }}"
          main = "build/worker/shim.mjs"
          compatibility_date = "2026-02-10"
          upload_source_maps = true

          [observability]
          enabled = true
          head_sampling_rate = 1

          [observability.traces]
          enabled = true
          head_sampling_rate = 0.1

          [build]
          command = "cargo install -q worker-build && worker-build --release"

          [[d1_databases]]
          binding = "rushomon"
          database_id = "${{ env.DB_ID }}"

          [[kv_namespaces]]
          binding = "URL_MAPPINGS"
          id = "${{ env.KV_ID }}"

          [assets]
          directory = "./frontend/build"
          binding = "ASSETS"
          run_worker_first = true
          not_found_handling = "none"

          [vars]
          GITHUB_CLIENT_ID = "${{ secrets.GH_CLIENT_ID }}"
          GITHUB_AUTHORIZE_URL = "https://github.com/login/oauth/authorize"
          GITHUB_TOKEN_URL = "https://github.com/login/oauth/access_token"
          GITHUB_USER_URL = "https://api.github.com/user"
          DOMAIN = "rushomon-pr-${{ env.PR_NUMBER }}.${{ env.WORKERS_DOMAIN }}"
          FRONTEND_URL = "https://rushomon-pr-${{ env.PR_NUMBER }}.${{ env.WORKERS_DOMAIN }}"
          ALLOWED_ORIGINS = "http://localhost:5173,http://localhost:5174,https://rushomon-pr-${{ env.PR_NUMBER }}.${{ env.WORKERS_DOMAIN }}"
          EPHEMERAL_ORIGIN_PATTERN = "https://rushomon-pr-{}.${{ env.WORKERS_DOMAIN }}"
          ENABLE_KV_RATE_LIMITING = "false"
          EOF

      - name: Apply D1 Migrations
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
        run: |
          # Wait for database to be ready
          sleep 2

          # Apply migrations using environment variables
          wrangler d1 migrations apply rushomon --remote -c wrangler.ephemeral.toml

      - name: Install Frontend Dependencies
        working-directory: frontend
        run: npm ci

      - name: Build Frontend for Unified Worker
        working-directory: frontend
        env:
          PUBLIC_VITE_API_BASE_URL: https://rushomon-pr-${{ steps.pr_number.outputs.pr_number }}.${{ secrets.WORKERS_DOMAIN }}
          PUBLIC_VITE_SHORT_LINK_BASE_URL: https://rushomon-pr-${{ steps.pr_number.outputs.pr_number }}.${{ secrets.WORKERS_DOMAIN }}
        run: |
          echo "ðŸ”¨ Building frontend for unified Worker (ephemeral)"
          echo "   API Base URL: https://rushomon-pr-${{ steps.pr_number.outputs.pr_number }}.${{ secrets.WORKERS_DOMAIN }}"
          echo "   Short Link Base URL: https://rushomon-pr-${{ steps.pr_number.outputs.pr_number }}.${{ secrets.WORKERS_DOMAIN }}"
          npm run build

      - name: Set Worker Secrets
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
          GH_CLIENT_SECRET: ${{ secrets.GH_CLIENT_SECRET }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
        run: |
          # Set secrets using wrangler secrets API (not visible in Worker dashboard)
          echo "$GH_CLIENT_SECRET" | wrangler secret put GITHUB_CLIENT_SECRET -c wrangler.ephemeral.toml
          echo "$JWT_SECRET" | wrangler secret put JWT_SECRET -c wrangler.ephemeral.toml

      - name: Deploy to Ephemeral Environment
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
        run: |
          wrangler deploy -c wrangler.ephemeral.toml

      - name: Setup Test Data
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
        run: |
          # Insert test link for redirect testing
          NOW=$(date +%s)
          echo "ðŸ”§ Setting up test data for smoke tests..."

          # Clean up any existing test data first
          echo "ðŸ§¹ Cleaning up existing test data..."
          echo "ðŸ” Database configuration check:"
          echo "  Using config: wrangler.ephemeral.toml"
          echo "  Database name: rushomon"

          # Verify database connection
          DB_CHECK=$(wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command "SELECT 'database_connected' as status" --json)
          echo "  Database test: $(echo "$DB_CHECK" | jq -r '.[0].results[0].status')"

          # Clean up in reverse dependency order to respect foreign key constraints
          echo "ðŸ—‘ï¸  Cleaning up analytics events first..."
          wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "DELETE FROM analytics_events WHERE link_id IN (SELECT id FROM links WHERE short_code = 'smoke-test')" || true

          echo "ðŸ—‘ï¸  Cleaning up link reports..."
          wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "DELETE FROM link_reports WHERE link_id IN (SELECT id FROM links WHERE short_code = 'smoke-test')" || true

          echo "ðŸ—‘ï¸  Cleaning up links..."
          wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "DELETE FROM links WHERE short_code = 'smoke-test'" || true

          echo "ðŸ—‘ï¸  Cleaning up users..."
          wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "DELETE FROM users WHERE id = 'test-user-smoke'" || true

          echo "ðŸ—‘ï¸  Cleaning up monthly counters..."
          wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "DELETE FROM monthly_counters WHERE org_id = 'test-org-smoke'" || true

          echo "ðŸ—‘ï¸  Cleaning up organizations..."
          wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "DELETE FROM organizations WHERE id = 'test-org-smoke'" || true

          # Create test organization and user first
          echo "ðŸ“ Creating test organization..."
          ORG_RESULT=$(wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "INSERT INTO organizations (id, name, slug, created_at, created_by) 
             VALUES ('test-org-smoke', 'Smoke Test Org', 'smoke-test', $NOW, 'test-user-smoke')" --json)
          echo "Organization insert result: $(echo "$ORG_RESULT" | jq '.[0].meta.changes // 0') changes"

          echo "ðŸ“ Creating test user..."
          USER_RESULT=$(wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "INSERT INTO users (id, email, name, oauth_provider, oauth_id, org_id, role, created_at) 
             VALUES ('test-user-smoke', 'smoke-test@example.com', 'Smoke Test User', 'github', '12345', 'test-org-smoke', 'admin', $NOW)" --json)
          echo "User insert result: $(echo "$USER_RESULT" | jq '.[0].meta.changes // 0') changes"

          # Create test link for redirect testing
          echo "ðŸ“ Creating test link in D1..."
          LINK_RESULT=$(wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "INSERT INTO links (id, org_id, short_code, destination_url, created_at, created_by, status, click_count)
             VALUES ('test-link-smoke', 'test-org-smoke', 'smoke-test', 'https://example.com', $NOW, 'test-user-smoke', 'active', 0)" --json)
          echo "Link insert result: $(echo "$LINK_RESULT" | jq '.[0].meta.changes // 0') changes"

          # Create KV mapping for redirect lookup
          echo "ðŸ“ Creating KV mapping for redirect..."
          wrangler kv key put smoke-test --binding URL_MAPPINGS --remote -c wrangler.ephemeral.toml --preview false '{"destination_url":"https://example.com","link_id":"test-link-smoke","expires_at":null,"status":"active"}'
          echo "KV mapping result: Created"

          # Verify test data was created
          echo "ðŸ” Verifying test data..."
          LINK_COUNT=$(wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "SELECT COUNT(*) as count FROM links WHERE short_code = 'smoke-test'" --json | jq -r '.[0].results[0].count')

          echo "ðŸ“Š Database state check:"
          echo "  Links with short_code 'smoke-test': $LINK_COUNT"

          # Verify KV mapping was created
          echo "ðŸ” KV state check:"
          KV_CHECK=$(wrangler kv key get smoke-test --binding URL_MAPPINGS --remote -c wrangler.ephemeral.toml --preview false 2>/dev/null || echo "KV_NOT_FOUND")

          if [ "$KV_CHECK" = "KV_NOT_FOUND" ]; then
            echo "  KV mapping: âŒ Not found"
          elif [ -z "$KV_CHECK" ]; then
            echo "  KV mapping: âŒ Found but empty (possible command error)"
            echo "  This indicates a wrangler command syntax issue"
            exit 1
          else
            # Validate JSON structure and content
            DEST_URL=$(echo "$KV_CHECK" | jq -r '.destination_url // empty' 2>/dev/null)
            LINK_ID=$(echo "$KV_CHECK" | jq -r '.link_id // empty' 2>/dev/null)
            STATUS=$(echo "$KV_CHECK" | jq -r '.status // empty' 2>/dev/null)

            if [ "$DEST_URL" = "https://example.com" ] && [ "$LINK_ID" = "test-link-smoke" ] && [ "$STATUS" = "active" ]; then
              echo "  KV mapping: âœ… Found and validated"
              echo "  Destination: $DEST_URL"
              echo "  Link ID: $LINK_ID"
              echo "  Status: $STATUS"
            else
              echo "  KV mapping: âŒ Found but invalid content"
              echo "  Expected: destination_url=https://example.com, link_id=test-link-smoke, status=active"
              echo "  Got: destination_url=$DEST_URL, link_id=$LINK_ID, status=$STATUS"
              echo "  Raw KV value: $KV_CHECK"
              exit 1
            fi
          fi

          # Show all links for debugging
          echo "  All links in database:"
          wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "SELECT id, short_code, destination_url, status FROM links LIMIT 10" --json | jq '.[0].results[] | {id, short_code, destination_url, status}' || echo "Failed to query links"

          if [ "$LINK_COUNT" = "1" ] && [ "$KV_CHECK" != "KV_NOT_FOUND" ] && [ -n "$KV_CHECK" ] && \
             [ "$(echo "$KV_CHECK" | jq -r '.destination_url // empty' 2>/dev/null)" = "https://example.com" ] && \
             [ "$(echo "$KV_CHECK" | jq -r '.link_id // empty' 2>/dev/null)" = "test-link-smoke" ] && \
             [ "$(echo "$KV_CHECK" | jq -r '.status // empty' 2>/dev/null)" = "active" ]; then
            echo "âœ… Test link 'smoke-test' created successfully (D1 + KV)"
            # Show the specific link details
            echo "ðŸ“‹ Link details:"
            wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
              "SELECT id, short_code, destination_url, status FROM links WHERE short_code = 'smoke-test'" --json | jq '.[0].results[]' || echo "Failed to get link details"
          else
            echo "âŒ Test link creation failed:"
            echo "  D1 links: $LINK_COUNT (expected: 1)"
            echo "  KV mapping: $([ "$KV_CHECK" = "KV_NOT_FOUND" ] && echo "âŒ Missing" || echo "âœ… Found")"
            echo "ðŸ” Debugging database state..."
            wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
              "SELECT id, short_code, destination_url, status FROM links WHERE short_code = 'smoke-test'" --json | jq '.' || true
            exit 1
          fi

          echo "âœ… Test data setup complete"

      - name: Run Smoke Tests
        env:
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
          WORKERS_DOMAIN: ${{ secrets.WORKERS_DOMAIN }}
        run: |
          DEPLOYMENT_URL="https://rushomon-pr-$PR_NUMBER.$WORKERS_DOMAIN"

          echo "ðŸ§ª Testing deployment at: $DEPLOYMENT_URL"

          # Wait for deployment to be ready
          sleep 3

          # Test 1: Root endpoint health check
          echo ""
          echo "ðŸ¥ Test 1: Root Endpoint (Health Check)"
          echo "----------------------------------------"
          echo "Testing $DEPLOYMENT_URL/..."

          HEALTH_RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" "$DEPLOYMENT_URL/" || echo "FAILED")
          HTTP_CODE=$(echo "$HEALTH_RESPONSE" | tail -n1 | cut -d: -f2)
          RESPONSE_BODY=$(echo "$HEALTH_RESPONSE" | sed '$d')

          echo "HTTP Status: $HTTP_CODE"
          echo "Response Body: $RESPONSE_BODY"

          if [ "$HTTP_CODE" != "200" ]; then
            echo "âŒ Root endpoint failed with HTTP $HTTP_CODE"
            echo "Response: $RESPONSE_BODY"
            exit 1
          else
            echo "âœ… Root endpoint (health check) passed"
            echo "ðŸ“ Worker is responding with the expected banner"
          fi

          # Test 2: Public Redirect
          echo ""
          echo "ðŸ”„ Test 2: Public Redirect"
          echo "--------------------------"
          echo "Testing /smoke-test redirect (public endpoint)..."

          REDIRECT_RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" \
            -I "$DEPLOYMENT_URL/smoke-test" || echo "FAILED")
          REDIRECT_HTTP_CODE=$(echo "$REDIRECT_RESPONSE" | tail -n1 | cut -d: -f2)

          echo "Redirect HTTP: $REDIRECT_HTTP_CODE"

          if [ "$REDIRECT_HTTP_CODE" = "301" ] || [ "$REDIRECT_HTTP_CODE" = "302" ]; then
            echo "âœ… Public redirect working (HTTP $REDIRECT_HTTP_CODE)"
            # Extract redirect location for verification
            LOCATION=$(echo "$REDIRECT_RESPONSE" | grep -i location | cut -d' ' -f2- | tr -d '\r')
            echo "ðŸ“ Redirects to: $LOCATION"
          else
            echo "âŒ Redirect test failed (HTTP $REDIRECT_HTTP_CODE)"
            echo "Response: $REDIRECT_RESPONSE"
            echo ""
            echo "ðŸ” Debugging redirect test failure..."
            echo "Expected: 301 or 302 redirect"
            echo "Got: $REDIRECT_HTTP_CODE"
            echo "Test URL: $DEPLOYMENT_URL/smoke-test"
            echo "This suggests the test link 'smoke-test' was not created properly in the database."
            exit 1
          fi

          # Test 3: Authentication Validation
          echo ""
          echo "ðŸ” Test 3: Authentication Validation"
          echo "---------------------------------"
          echo "Testing that protected endpoints reject unauthenticated requests..."

          # Test key protected endpoints
          for endpoint in "/api/links" "/api/auth/me"; do
            echo -n "  $endpoint: "

            AUTH_RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" \
              "$DEPLOYMENT_URL$endpoint" || echo "FAILED")
            AUTH_HTTP_CODE=$(echo "$AUTH_RESPONSE" | tail -n1 | cut -d: -f2)

            if [ "$AUTH_HTTP_CODE" = "401" ]; then
              echo "âœ… Correctly requires authentication"
            else
              echo "âŒ Expected 401, got $AUTH_HTTP_CODE"
              AUTH_BODY=$(echo "$AUTH_RESPONSE" | sed '$d')
              echo "  Response: $AUTH_BODY"
              exit 1
            fi
          done

          echo "âœ… Authentication properly enforced"

          # Test 4: 404 Page for Nonexistent Short Code
          echo ""
          echo "ðŸ”— Test 4: Nonexistent Short Code Redirect"
          echo "--------------------------------------------"
          echo "Testing that nonexistent short codes redirect to /404..."

          NOT_FOUND_RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" \
            -I "$DEPLOYMENT_URL/doesnotexist999" || echo "FAILED")
          NOT_FOUND_HTTP_CODE=$(echo "$NOT_FOUND_RESPONSE" | tail -n1 | cut -d: -f2)

          echo "HTTP Status: $NOT_FOUND_HTTP_CODE"

          if [ "$NOT_FOUND_HTTP_CODE" = "302" ]; then
            NOT_FOUND_LOCATION=$(echo "$NOT_FOUND_RESPONSE" | grep -i location | cut -d' ' -f2- | tr -d '\r')
            echo "ðŸ“ Redirects to: $NOT_FOUND_LOCATION"
            if echo "$NOT_FOUND_LOCATION" | grep -q "/404"; then
              echo "âœ… Nonexistent short code correctly redirects to /404"
            else
              echo "âŒ Redirect location doesn't contain /404: $NOT_FOUND_LOCATION"
              exit 1
            fi
          else
            echo "âŒ Expected 302 redirect, got HTTP $NOT_FOUND_HTTP_CODE"
            exit 1
          fi

          # Test 5: Check available endpoints
          echo ""
          echo "ðŸ“‹ Test 5: Check Available Endpoints"
          echo "------------------------------------"

          echo "Testing common endpoints..."

          # Test common endpoints (follow redirects for / since ASSETS serves it)
          for endpoint in "/" "/favicon.ico" "/404"; do
            echo -n "  $endpoint: "

            ENDPOINT_RESPONSE=$(curl -s -L -w "\nHTTP_CODE:%{http_code}" "$DEPLOYMENT_URL$endpoint" || echo "FAILED")
            ENDPOINT_HTTP_CODE=$(echo "$ENDPOINT_RESPONSE" | tail -n1 | cut -d: -f2)
            if [ "$ENDPOINT_HTTP_CODE" = "200" ]; then
              echo "âœ… Accessible"
            else
              echo "âš ï¸  HTTP $ENDPOINT_HTTP_CODE"
            fi
          done

          # Test that protected endpoint returns 401
          echo -n "  /api/links (protected): "
          PROTECTED_RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" "$DEPLOYMENT_URL/api/links" || echo "FAILED")
          PROTECTED_HTTP_CODE=$(echo "$PROTECTED_RESPONSE" | tail -n1 | cut -d: -f2)
          if [ "$PROTECTED_HTTP_CODE" = "401" ]; then
            echo "âœ… Correctly protected"
          else
            echo "âŒ Expected 401, got $PROTECTED_HTTP_CODE"
            exit 1
          fi

          echo ""
          echo "ðŸŽ¯ Smoke Tests Summary"
          echo "====================="
          echo "âœ… Public endpoints working"
          echo "âœ… Authentication properly enforced"
          echo "âœ… Redirect logic working"
          echo "âœ… Worker deployment verified"

      - name: Capture Worker Logs on Failure
        if: failure()
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
        run: |
          echo "ðŸ” Worker logs are not available in GitHub Actions"
          echo "ðŸ“‹ To debug this failure, run locally:"
          echo ""
          echo "  wrangler tail rushomon-pr-$PR_NUMBER"
          echo ""
          echo "Then trigger the failing request manually to see the error logs."

      - name: Store Deployment Info
        if: always()
        env:
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
          DB_ID: ${{ steps.create_d1.outputs.database_id }}
          KV_ID: ${{ steps.create_kv.outputs.kv_id }}
          WORKERS_DOMAIN: ${{ secrets.WORKERS_DOMAIN }}
        run: |
          mkdir -p .github/ephemeral-envs
          cat > .github/ephemeral-envs/pr-$PR_NUMBER.json << EOF
          {
            "pr_number": "$PR_NUMBER",
            "database_id": "$DB_ID",
            "kv_id": "$KV_ID",
            "pages_branch": "pr-$PR_NUMBER",
            "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "frontend_url": "https://pr-$PR_NUMBER.rushomon-ui.pages.dev",
            "backend_url": "https://rushomon-pr-$PR_NUMBER.$WORKERS_DOMAIN"
          }
          EOF

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: thollander/actions-comment-pull-request@v3.0.1
        with:
          pr-number: ${{ steps.pr_number.outputs.pr_number }}
          message: |
            ðŸš€ **Ephemeral Environment Deployed (Unified Worker)**

            **Application**: [https://rushomon-pr-${{ steps.pr_number.outputs.pr_number }}.${{ secrets.WORKERS_DOMAIN }}](https://rushomon-pr-${{ steps.pr_number.outputs.pr_number }}.${{ secrets.WORKERS_DOMAIN }})

            This unified Worker deployment serves both frontend and backend from the same domain for better security (httpOnly cookies work correctly).

            This environment will be automatically cleaned up when the PR is closed.

            **Worker**: `rushomon-pr-${{ steps.pr_number.outputs.pr_number }}`

            ---

            ðŸ’¡ **Tip**: To skip preview deployment, add the `skip-preview` label to this PR.

  # Job that runs when deployment is skipped to inform the user
  deployment-skipped:
    name: Deployment Skipped Notification
    runs-on: ubuntu-latest
    # Run if PR event but deployment was skipped due to conditions
    if: |
      github.event_name == 'pull_request' &&
      github.event.pull_request.head.repo.full_name == github.repository &&
      (github.event.pull_request.draft == true ||
       contains(github.event.pull_request.labels.*.name, 'skip-preview'))

    steps:
      - name: Comment why deployment was skipped
        uses: thollander/actions-comment-pull-request@v3.0.1
        with:
          pr-number: ${{ github.event.pull_request.number }}
          message: |
            â­ï¸ **Ephemeral Environment Deployment Skipped**

            Preview deployment was not triggered because:
            ${{ github.event.pull_request.draft == true && '- âœï¸ This PR is in **draft** state' || '' }}
            ${{ contains(github.event.pull_request.labels.*.name, 'skip-preview') && '- ðŸ·ï¸ This PR has the **skip-preview** label' || '' }}

            **To enable deployment:**
            ${{ github.event.pull_request.draft == true && '- Mark this PR as "Ready for review"' || '' }}
            ${{ contains(github.event.pull_request.labels.*.name, 'skip-preview') && '- Remove the `skip-preview` label' || '' }}

            *Note: Deployments are also skipped for documentation-only changes.*
