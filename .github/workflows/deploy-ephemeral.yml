name: Deploy Ephemeral Environment

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, labeled, unlabeled]
    # Only trigger if code files change (skip docs-only changes)
    paths:
      - 'src/**'
      - 'tests/**'
      - 'Cargo.toml'
      - 'Cargo.lock'
      - 'wrangler.toml'
      - 'migrations/**'
      - '.github/workflows/deploy-ephemeral.yml'

permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: ephemeral-${{ github.head_ref || github.ref }}
  cancel-in-progress: true

jobs:
  deploy-ephemeral:
    name: Deploy to Ephemeral Environment
    runs-on: ubuntu-latest
    timeout-minutes: 20
    # Deploy only if:
    # 1. PR is from the same repo (not a fork) OR it's a push event
    # 2. PR is not in draft state
    # 3. PR does not have 'skip-preview' label
    if: |
      (github.event_name == 'pull_request' &&
       github.event.pull_request.head.repo.full_name == github.repository &&
       github.event.pull_request.draft == false &&
       !contains(github.event.pull_request.labels.*.name, 'skip-preview')) ||
      github.event_name == 'push'

    steps:
      - uses: actions/checkout@v4

      - name: Determine PR Number
        id: pr_number
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          else
            # For push events on non-main branches, extract from branch name or use commit SHA
            PR_NUM=$(echo "${{ github.ref }}" | sed 's|refs/heads/||' | grep -oE '[0-9]+' | head -1)
            if [ -z "$PR_NUM" ]; then
              PR_NUM=$(echo "${{ github.sha }}" | cut -c1-7)
            fi
            echo "pr_number=$PR_NUM" >> $GITHUB_OUTPUT
          fi

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache Rust
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: '.'

      - name: Cache npm
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install wrangler and worker-build
        run: |
          npm install -g wrangler
          cargo install -q worker-build

      - name: Build Worker
        run: worker-build --release

      - name: Create D1 Database
        id: create_d1
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
        run: |
          DB_NAME="rushomon-pr-$PR_NUMBER"

          # Check if database already exists
          echo "Checking if database '$DB_NAME' already exists..."
          LIST_RESPONSE=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/d1/database" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN")

          DB_ID=$(echo "$LIST_RESPONSE" | jq -r ".result[] | select(.name == \"$DB_NAME\") | .uuid // .id" | head -1)

          if [ -n "$DB_ID" ]; then
            echo "âœ… Database already exists: $DB_NAME (ID: $DB_ID)"
          else
            echo "ðŸ†• Creating new database: $DB_NAME"

            # Create database via Cloudflare API
            RESPONSE=$(curl -s -X POST \
              "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/d1/database" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"name\": \"$DB_NAME\"}")

            DB_ID=$(echo "$RESPONSE" | jq -r '.result.uuid // .result.id // empty')

            if [ -z "$DB_ID" ]; then
              echo "âŒ Failed to create D1 database"
              echo "Response: $RESPONSE"
              exit 1
            fi

            echo "âœ… Created database: $DB_NAME (ID: $DB_ID)"
          fi

          echo "database_id=$DB_ID" >> $GITHUB_OUTPUT
          echo "database_name=$DB_NAME" >> $GITHUB_OUTPUT

      - name: Create KV Namespace
        id: create_kv
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
        run: |
          KV_NAME="URL_MAPPINGS_pr_$PR_NUMBER"

          # Check if KV namespace already exists
          echo "Checking if KV namespace '$KV_NAME' already exists..."
          LIST_RESPONSE=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/storage/kv/namespaces" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN")

          KV_ID=$(echo "$LIST_RESPONSE" | jq -r ".result[] | select(.title == \"$KV_NAME\") | .id" | head -1)

          if [ -n "$KV_ID" ]; then
            echo "âœ… KV namespace already exists: $KV_NAME (ID: $KV_ID)"
          else
            echo "ðŸ†• Creating new KV namespace: $KV_NAME"

            # Create KV namespace via Cloudflare API
            RESPONSE=$(curl -s -X POST \
              "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/storage/kv/namespaces" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"title\": \"$KV_NAME\"}")

            KV_ID=$(echo "$RESPONSE" | jq -r '.result.id // empty')

            if [ -z "$KV_ID" ]; then
              echo "âŒ Failed to create KV namespace"
              echo "Response: $RESPONSE"
              exit 1
            fi

            echo "âœ… Created KV namespace: $KV_NAME (ID: $KV_ID)"
          fi

          echo "kv_id=$KV_ID" >> $GITHUB_OUTPUT
          echo "kv_name=$KV_NAME" >> $GITHUB_OUTPUT

      - name: Create Ephemeral wrangler.toml
        env:
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
          DB_ID: ${{ steps.create_d1.outputs.database_id }}
          KV_ID: ${{ steps.create_kv.outputs.kv_id }}
          WORKERS_DOMAIN: ${{ secrets.WORKERS_DOMAIN }}
        run: |
          cat > wrangler.ephemeral.toml << 'EOF'
          name = "rushomon-pr-${{ env.PR_NUMBER }}"
          main = "build/worker/shim.mjs"
          compatibility_date = "2024-01-31"

          [build]
          command = "cargo install -q worker-build && worker-build --release"

          [[d1_databases]]
          binding = "rushomon"
          database_id = "${{ env.DB_ID }}"

          [[kv_namespaces]]
          binding = "URL_MAPPINGS"
          id = "${{ env.KV_ID }}"

          [vars]
          GITHUB_CLIENT_ID = "${{ secrets.GH_CLIENT_ID }}"
          GITHUB_CLIENT_SECRET = "${{ secrets.GH_CLIENT_SECRET }}"
          JWT_SECRET = "${{ secrets.JWT_SECRET }}"
          DOMAIN = "${{ env.WORKERS_DOMAIN }}"
          EOF

      - name: Apply D1 Migrations
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
        run: |
          # Wait for database to be ready
          sleep 2

          # Apply migrations using environment variables
          wrangler d1 migrations apply rushomon --remote -c wrangler.ephemeral.toml

      - name: Deploy to Ephemeral Environment
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
        run: |
          wrangler deploy -c wrangler.ephemeral.toml

      - name: Setup Test Data
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
        run: |
          # Insert test link for redirect testing
          NOW=$(date +%s)
          echo "ðŸ”§ Setting up test data for smoke tests..."

          # Clean up any existing test data first
          echo "ðŸ§¹ Cleaning up existing test data..."
          echo "ðŸ” Database configuration check:"
          echo "  Using config: wrangler.ephemeral.toml"
          echo "  Database name: rushomon"

          # Verify database connection
          DB_CHECK=$(wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command "SELECT 'database_connected' as status" --json)
          echo "  Database test: $(echo "$DB_CHECK" | jq -r '.[0].results[0].status')"

          wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "DELETE FROM links WHERE short_code = 'smoke-test'" || true
          wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "DELETE FROM users WHERE id = 'test-user-smoke'" || true
          wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "DELETE FROM organizations WHERE id = 'test-org-smoke'" || true

          # Create test organization and user first
          echo "ðŸ“ Creating test organization..."
          ORG_RESULT=$(wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "INSERT INTO organizations (id, name, slug, created_at, created_by) 
             VALUES ('test-org-smoke', 'Smoke Test Org', 'smoke-test', $NOW, 'test-user-smoke')" --json)
          echo "Organization insert result: $(echo "$ORG_RESULT" | jq '.[0].meta.changes // 0') changes"

          echo "ðŸ“ Creating test user..."
          USER_RESULT=$(wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "INSERT INTO users (id, email, name, oauth_provider, oauth_id, org_id, role, created_at) 
             VALUES ('test-user-smoke', 'smoke-test@example.com', 'Smoke Test User', 'github', '12345', 'test-org-smoke', 'admin', $NOW)" --json)
          echo "User insert result: $(echo "$USER_RESULT" | jq '.[0].meta.changes // 0') changes"

          # Create test link for redirect testing
          echo "ðŸ“ Creating test link in D1..."
          LINK_RESULT=$(wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "INSERT INTO links (id, org_id, short_code, destination_url, created_at, created_by, is_active) 
             VALUES ('test-link-smoke', 'test-org-smoke', 'smoke-test', 'https://example.com', $NOW, 'test-user-smoke', 1)" --json)
          echo "Link insert result: $(echo "$LINK_RESULT" | jq '.[0].meta.changes // 0') changes"

          # Create KV mapping for redirect lookup
          echo "ðŸ“ Creating KV mapping for redirect..."
          wrangler kv key put smoke-test --binding URL_MAPPINGS --remote -c wrangler.ephemeral.toml --preview false '{"destination_url":"https://example.com","link_id":"test-link-smoke","expires_at":null,"is_active":true}'
          echo "KV mapping result: Created"

          # Verify test data was created
          echo "ðŸ” Verifying test data..."
          LINK_COUNT=$(wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "SELECT COUNT(*) as count FROM links WHERE short_code = 'smoke-test'" --json | jq -r '.[0].results[0].count')

          echo "ðŸ“Š Database state check:"
          echo "  Links with short_code 'smoke-test': $LINK_COUNT"

          # Verify KV mapping was created
          echo "ðŸ” KV state check:"
          KV_CHECK=$(wrangler kv key get smoke-test --binding URL_MAPPINGS --remote -c wrangler.ephemeral.toml --preview false --json || echo "KV_NOT_FOUND")

          if [ "$KV_CHECK" != "KV_NOT_FOUND" ]; then
            echo "  KV mapping: âœ… Found"
            echo "  KV value: $KV_CHECK"
          else
            echo "  KV mapping: âŒ Not found"
          fi

          # Show all links for debugging
          echo "  All links in database:"
          wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
            "SELECT id, short_code, destination_url, is_active FROM links LIMIT 10" --json | jq '.[0].results[] | {id, short_code, destination_url, is_active}' || echo "Failed to query links"

          if [ "$LINK_COUNT" = "1" ] && [ "$KV_CHECK" != "KV_NOT_FOUND" ]; then
            echo "âœ… Test link 'smoke-test' created successfully (D1 + KV)"
            # Show the specific link details
            echo "ðŸ“‹ Link details:"
            wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
              "SELECT id, short_code, destination_url, is_active FROM links WHERE short_code = 'smoke-test'" --json | jq '.[0].results[]' || echo "Failed to get link details"
          else
            echo "âŒ Test link creation failed:"
            echo "  D1 links: $LINK_COUNT (expected: 1)"
            echo "  KV mapping: $([ "$KV_CHECK" = "KV_NOT_FOUND" ] && echo "âŒ Missing" || echo "âœ… Found")"
            echo "ðŸ” Debugging database state..."
            wrangler d1 execute rushomon --remote -c wrangler.ephemeral.toml --command \
              "SELECT id, short_code, destination_url, is_active FROM links WHERE short_code = 'smoke-test'" --json | jq '.' || true
            exit 1
          fi

          echo "âœ… Test data setup complete"

      - name: Run Smoke Tests
        env:
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
          WORKERS_DOMAIN: ${{ secrets.WORKERS_DOMAIN }}
        run: |
          DEPLOYMENT_URL="https://rushomon-pr-$PR_NUMBER.$WORKERS_DOMAIN"

          echo "ðŸ§ª Testing deployment at: $DEPLOYMENT_URL"

          # Wait for deployment to be ready
          sleep 3

          # Test 1: Root endpoint health check
          echo ""
          echo "ðŸ¥ Test 1: Root Endpoint (Health Check)"
          echo "----------------------------------------"
          echo "Testing $DEPLOYMENT_URL/..."

          HEALTH_RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" "$DEPLOYMENT_URL/" || echo "FAILED")
          HTTP_CODE=$(echo "$HEALTH_RESPONSE" | tail -n1 | cut -d: -f2)
          RESPONSE_BODY=$(echo "$HEALTH_RESPONSE" | sed '$d')

          echo "HTTP Status: $HTTP_CODE"
          echo "Response Body: $RESPONSE_BODY"

          if [ "$HTTP_CODE" != "200" ]; then
            echo "âŒ Root endpoint failed with HTTP $HTTP_CODE"
            echo "Response: $RESPONSE_BODY"
            exit 1
          else
            echo "âœ… Root endpoint (health check) passed"
            echo "ðŸ“ Worker is responding with the expected banner"
          fi

          # Test 2: Public Redirect
          echo ""
          echo "ðŸ”„ Test 2: Public Redirect"
          echo "--------------------------"
          echo "Testing /smoke-test redirect (public endpoint)..."

          REDIRECT_RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" \
            -I "$DEPLOYMENT_URL/smoke-test" || echo "FAILED")
          REDIRECT_HTTP_CODE=$(echo "$REDIRECT_RESPONSE" | tail -n1 | cut -d: -f2)

          echo "Redirect HTTP: $REDIRECT_HTTP_CODE"

          if [ "$REDIRECT_HTTP_CODE" = "301" ] || [ "$REDIRECT_HTTP_CODE" = "302" ]; then
            echo "âœ… Public redirect working (HTTP $REDIRECT_HTTP_CODE)"
            # Extract redirect location for verification
            LOCATION=$(echo "$REDIRECT_RESPONSE" | grep -i location | cut -d' ' -f2- | tr -d '\r')
            echo "ðŸ“ Redirects to: $LOCATION"
          else
            echo "âŒ Redirect test failed (HTTP $REDIRECT_HTTP_CODE)"
            echo "Response: $REDIRECT_RESPONSE"
            echo ""
            echo "ðŸ” Debugging redirect test failure..."
            echo "Expected: 301 or 302 redirect"
            echo "Got: $REDIRECT_HTTP_CODE"
            echo "Test URL: $DEPLOYMENT_URL/smoke-test"
            echo "This suggests the test link 'smoke-test' was not created properly in the database."
            exit 1
          fi

          # Test 3: Authentication Validation
          echo ""
          echo "ðŸ” Test 3: Authentication Validation"
          echo "---------------------------------"
          echo "Testing that protected endpoints reject unauthenticated requests..."

          # Test key protected endpoints
          for endpoint in "/api/links" "/api/auth/me"; do
            echo -n "  $endpoint: "

            AUTH_RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" \
              "$DEPLOYMENT_URL$endpoint" || echo "FAILED")
            AUTH_HTTP_CODE=$(echo "$AUTH_RESPONSE" | tail -n1 | cut -d: -f2)

            if [ "$AUTH_HTTP_CODE" = "401" ]; then
              echo "âœ… Correctly requires authentication"
            else
              echo "âŒ Expected 401, got $AUTH_HTTP_CODE"
              AUTH_BODY=$(echo "$AUTH_RESPONSE" | sed '$d')
              echo "  Response: $AUTH_BODY"
              exit 1
            fi
          done

          echo "âœ… Authentication properly enforced"

          # Test 4: Check available endpoints
          echo ""
          echo "ðŸ“‹ Test 4: Check Available Endpoints"
          echo "------------------------------------"

          echo "Testing common endpoints..."

          # Test common endpoints
          for endpoint in "/" "/favicon.ico"; do
            echo -n "  $endpoint: "

            if curl -s -f "$DEPLOYMENT_URL$endpoint" >/dev/null 2>&1; then
              echo "âœ… Accessible"
            else
              echo "âŒ Not accessible"
            fi
          done

          # Test that protected endpoint returns 401
          echo -n "  /api/links (protected): "
          PROTECTED_RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" "$DEPLOYMENT_URL/api/links" || echo "FAILED")
          PROTECTED_HTTP_CODE=$(echo "$PROTECTED_RESPONSE" | tail -n1 | cut -d: -f2)
          if [ "$PROTECTED_HTTP_CODE" = "401" ]; then
            echo "âœ… Correctly protected"
          else
            echo "âŒ Expected 401, got $PROTECTED_HTTP_CODE"
            exit 1
          fi

          echo ""
          echo "ðŸŽ¯ Smoke Tests Summary"
          echo "====================="
          echo "âœ… Public endpoints working"
          echo "âœ… Authentication properly enforced"
          echo "âœ… Redirect logic working"
          echo "âœ… Worker deployment verified"

      - name: Store Deployment Info
        if: always()
        env:
          PR_NUMBER: ${{ steps.pr_number.outputs.pr_number }}
          DB_ID: ${{ steps.create_d1.outputs.database_id }}
          KV_ID: ${{ steps.create_kv.outputs.kv_id }}
          WORKERS_DOMAIN: ${{ secrets.WORKERS_DOMAIN }}
        run: |
          mkdir -p .github/ephemeral-envs
          cat > .github/ephemeral-envs/pr-$PR_NUMBER.json << EOF
          {
            "pr_number": "$PR_NUMBER",
            "database_id": "$DB_ID",
            "kv_id": "$KV_ID",
            "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "deployment_url": "https://rushomon-pr-$PR_NUMBER.$WORKERS_DOMAIN"
          }
          EOF

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: thollander/actions-comment-pull-request@v3.0.1
        with:
          pr-number: ${{ steps.pr_number.outputs.pr_number }}
          message: |
            ðŸš€ **Ephemeral Environment Deployed**

            **URL**: [https://rushomon-pr-${{ steps.pr_number.outputs.pr_number }}.${{ secrets.WORKERS_DOMAIN }}](https://rushomon-pr-${{ steps.pr_number.outputs.pr_number }}.${{ secrets.WORKERS_DOMAIN }})

            This environment will be automatically cleaned up when the PR is closed.

            **Database ID**: `${{ steps.create_d1.outputs.database_id }}`
            **KV Namespace ID**: `${{ steps.create_kv.outputs.kv_id }}`

            ---

            ðŸ’¡ **Tip**: To skip preview deployment, add the `skip-preview` label to this PR.

  # Job that runs when deployment is skipped to inform the user
  deployment-skipped:
    name: Deployment Skipped Notification
    runs-on: ubuntu-latest
    # Run if PR event but deployment was skipped due to conditions
    if: |
      github.event_name == 'pull_request' &&
      github.event.pull_request.head.repo.full_name == github.repository &&
      (github.event.pull_request.draft == true ||
       contains(github.event.pull_request.labels.*.name, 'skip-preview'))

    steps:
      - name: Comment why deployment was skipped
        uses: thollander/actions-comment-pull-request@v3.0.1
        with:
          pr-number: ${{ github.event.pull_request.number }}
          message: |
            â­ï¸ **Ephemeral Environment Deployment Skipped**

            Preview deployment was not triggered because:
            ${{ github.event.pull_request.draft == true && '- âœï¸ This PR is in **draft** state' || '' }}
            ${{ contains(github.event.pull_request.labels.*.name, 'skip-preview') && '- ðŸ·ï¸ This PR has the **skip-preview** label' || '' }}

            **To enable deployment:**
            ${{ github.event.pull_request.draft == true && '- Mark this PR as "Ready for review"' || '' }}
            ${{ contains(github.event.pull_request.labels.*.name, 'skip-preview') && '- Remove the `skip-preview` label' || '' }}

            *Note: Deployments are also skipped for documentation-only changes.*
