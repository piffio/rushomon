name: Deploy to Production

on:
  push:
    branches:
      - main
      - feat/13-setup-e-to-e-production-environment-and-cicd-with-dedicated-domains
  # TODO: Remove workflow_dispatch before merging to main - for testing only
  workflow_dispatch:
    inputs:
      test_mode:
        description: 'Run in test mode (uses test domains)'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  actions: read

concurrency:
  group: production-deploy
  cancel-in-progress: false

jobs:
  wait-for-tests:
    name: Wait for Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Check test workflow status
        uses: actions/github-script@v7
        with:
          script: |
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'test.yml',
              head_sha: context.sha,
              status: 'completed'
            });

            if (runs.workflow_runs.length === 0) {
              throw new Error('Test workflow has not completed yet');
            }

            const testRun = runs.workflow_runs[0];
            if (testRun.conclusion !== 'success') {
              throw new Error(`Test workflow failed with conclusion: ${testRun.conclusion}`);
            }

            console.log('‚úÖ All tests passed');

  deploy-backend:
    name: Deploy Backend (Worker)
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: wait-for-tests
    environment:
      name: production
      url: https://rush.mn

    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache Rust
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: '.'

      - name: Cache npm
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install wrangler and worker-build
        run: |
          npm install -g wrangler
          cargo install -q worker-build

      - name: Build Worker
        run: worker-build --release

      - name: Generate Production wrangler.toml
        env:
          D1_DATABASE_ID: ${{ secrets.D1_DATABASE_ID }}
          KV_NAMESPACE_ID: ${{ secrets.KV_NAMESPACE_ID }}
          GH_CLIENT_ID: ${{ secrets.GH_CLIENT_ID }}
          DOMAIN: ${{ secrets.DOMAIN }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
        run: |
          cat > wrangler.production.toml << EOF
          name = "rushomon-api"
          main = "build/worker/shim.mjs"
          compatibility_date = "2024-01-31"

          [[routes]]
          pattern = "${DOMAIN}"
          custom_domain = true

          [[d1_databases]]
          binding = "rushomon"
          database_name = "rushomon"
          database_id = "${D1_DATABASE_ID}"

          [[kv_namespaces]]
          binding = "URL_MAPPINGS"
          id = "${KV_NAMESPACE_ID}"

          [vars]
          GITHUB_CLIENT_ID = "${GH_CLIENT_ID}"
          DOMAIN = "${DOMAIN}"
          FRONTEND_URL = "${FRONTEND_URL}"
          ALLOWED_ORIGINS = "${FRONTEND_URL}"
          EOF

          echo "‚úÖ Generated wrangler.production.toml"
          echo "   Worker name: rushomon-api"
          echo "   Custom domain: ${DOMAIN}"
          echo "   Frontend URL: ${FRONTEND_URL}"

      - name: Apply D1 Migrations
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          echo "üìã Applying D1 migrations to production database..."
          wrangler d1 migrations apply rushomon --remote -c wrangler.production.toml
          echo "‚úÖ Production migrations applied successfully"

      - name: Deploy Worker
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          echo "üöÄ Deploying worker to production..."
          wrangler deploy -c wrangler.production.toml
          echo "‚úÖ Worker deployed successfully"

      - name: Set Worker Secrets
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          GH_CLIENT_SECRET: ${{ secrets.GH_CLIENT_SECRET }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
        run: |
          echo "üîê Setting worker secrets..."

          # Set GITHUB_CLIENT_SECRET
          RESPONSE=$(curl -s -X PUT \
            "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/workers/scripts/rushomon-api/secrets" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json" \
            -d "{\"name\": \"GITHUB_CLIENT_SECRET\", \"text\": \"$GH_CLIENT_SECRET\", \"type\": \"secret_text\"}")
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success // false')
          if [ "$SUCCESS" = "true" ]; then
            echo "  ‚úÖ GITHUB_CLIENT_SECRET set"
          else
            echo "  ‚ö†Ô∏è  GITHUB_CLIENT_SECRET may already be set or failed: $(echo "$RESPONSE" | jq -r '.errors[0].message // "unknown"')"
          fi

          # Set JWT_SECRET
          RESPONSE=$(curl -s -X PUT \
            "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/workers/scripts/rushomon-api/secrets" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json" \
            -d "{\"name\": \"JWT_SECRET\", \"text\": \"$JWT_SECRET\", \"type\": \"secret_text\"}")
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success // false')
          if [ "$SUCCESS" = "true" ]; then
            echo "  ‚úÖ JWT_SECRET set"
          else
            echo "  ‚ö†Ô∏è  JWT_SECRET may already be set or failed: $(echo "$RESPONSE" | jq -r '.errors[0].message // "unknown"')"
          fi

          echo "‚úÖ Worker secrets configured"

  deploy-frontend:
    name: Deploy Frontend (Pages)
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: deploy-backend
    environment:
      name: production
      url: https://rushomon.cc

    steps:
      - uses: actions/checkout@v4

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache npm
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install Frontend Dependencies
        working-directory: frontend
        run: npm ci

      - name: Build Frontend
        working-directory: frontend
        env:
          PUBLIC_VITE_API_BASE_URL: https://${{ secrets.DOMAIN }}
        run: |
          echo "üî® Building frontend with API base URL: https://${{ secrets.DOMAIN }}"
          npm run build

      - name: Install wrangler
        run: npm install -g wrangler

      - name: Create Pages Project (if needed)
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          PROJECT_NAME="rushomon-ui"

          echo "Checking if Pages project '$PROJECT_NAME' exists..."

          PROJECT_EXISTS=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/pages/projects/$PROJECT_NAME" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            | jq -r '.success')

          if [ "$PROJECT_EXISTS" = "false" ]; then
            echo "üÜï Creating Pages project: $PROJECT_NAME"

            CREATE_RESPONSE=$(curl -s -X POST \
              "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/pages/projects" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data '{
                "name": "'"$PROJECT_NAME"'",
                "production_branch": "main",
                "build_config": {
                  "build_command": "",
                  "destination_dir": "build"
                }
              }')

            SUCCESS=$(echo "$CREATE_RESPONSE" | jq -r '.success // false')

            if [ "$SUCCESS" = "true" ]; then
              echo "‚úÖ Created Pages project: $PROJECT_NAME"
            else
              echo "‚ùå Failed to create Pages project"
              echo "Response: $CREATE_RESPONSE"
              exit 1
            fi
          else
            echo "‚úÖ Pages project already exists: $PROJECT_NAME"
          fi

      - name: Deploy Frontend to Cloudflare Pages
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          cd frontend
          echo "üöÄ Deploying frontend to Cloudflare Pages..."
          npx wrangler pages deploy build \
            --project-name="rushomon-ui" \
            --branch="main" \
            --commit-dirty=true
          echo "‚úÖ Frontend deployed successfully"

      - name: Attach Custom Domain to Pages
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
        run: |
          PROJECT_NAME="rushomon-ui"
          # Extract domain from FRONTEND_URL (remove https://)
          CUSTOM_DOMAIN=$(echo "$FRONTEND_URL" | sed 's|https://||')

          echo "üåê Checking custom domain '$CUSTOM_DOMAIN' for Pages project '$PROJECT_NAME'..."

          # Check if domain is already attached
          DOMAINS_RESPONSE=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/pages/projects/$PROJECT_NAME/domains" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN")

          EXISTING_DOMAIN=$(echo "$DOMAINS_RESPONSE" | jq -r ".result[] | select(.name == \"$CUSTOM_DOMAIN\") | .name" 2>/dev/null)

          if [ "$EXISTING_DOMAIN" = "$CUSTOM_DOMAIN" ]; then
            echo "‚úÖ Custom domain '$CUSTOM_DOMAIN' is already attached"
          else
            echo "üÜï Attaching custom domain '$CUSTOM_DOMAIN'..."

            ATTACH_RESPONSE=$(curl -s -X POST \
              "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/pages/projects/$PROJECT_NAME/domains" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"name\": \"$CUSTOM_DOMAIN\"}")

            SUCCESS=$(echo "$ATTACH_RESPONSE" | jq -r '.success // false')

            if [ "$SUCCESS" = "true" ]; then
              echo "‚úÖ Custom domain '$CUSTOM_DOMAIN' attached successfully"
              echo "   Note: DNS propagation and SSL certificate may take a few minutes"
            else
              ERROR_MSG=$(echo "$ATTACH_RESPONSE" | jq -r '.errors[0].message // "unknown error"')
              echo "‚ö†Ô∏è  Failed to attach custom domain: $ERROR_MSG"
              echo "   You may need to attach it manually via the Cloudflare dashboard:"
              echo "   Workers & Pages ‚Üí $PROJECT_NAME ‚Üí Custom domains ‚Üí Add domain"
              echo "   (This is not a fatal error ‚Äî the deployment itself succeeded)"
            fi
          fi

  smoke-tests:
    name: Production Smoke Tests
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [deploy-backend, deploy-frontend]
    environment:
      name: production

    steps:
      - name: Run Read-Only Smoke Tests
        env:
          DOMAIN: ${{ secrets.DOMAIN }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
        run: |
          BACKEND_URL="https://$DOMAIN"
          FRONTEND_DOMAIN="$FRONTEND_URL"

          echo "üß™ Running production smoke tests (read-only)"
          echo "   Backend: $BACKEND_URL"
          echo "   Frontend: $FRONTEND_DOMAIN"
          echo ""

          # Wait for deployment to propagate
          sleep 5

          TESTS_PASSED=0
          TESTS_FAILED=0

          # Test 1: Worker root endpoint
          echo "üè• Test 1: Worker Root Endpoint"
          echo "--------------------------------"
          RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" "$BACKEND_URL/" || echo "FAILED")
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1 | cut -d: -f2)

          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Worker is responding (HTTP $HTTP_CODE)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "‚ùå Worker root endpoint failed (HTTP $HTTP_CODE)"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          fi
          echo ""

          # Test 2: Frontend accessibility
          echo "üåê Test 2: Frontend Accessibility"
          echo "----------------------------------"
          RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" "$FRONTEND_DOMAIN/" || echo "FAILED")
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1 | cut -d: -f2)

          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Frontend is responding (HTTP $HTTP_CODE)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "‚ö†Ô∏è  Frontend returned HTTP $HTTP_CODE (may still be propagating)"
            echo "   This is expected on first deploy ‚Äî DNS/SSL may take a few minutes"
            # Don't fail on frontend ‚Äî it may take time for DNS to propagate
            TESTS_PASSED=$((TESTS_PASSED + 1))
          fi
          echo ""

          # Test 3: Auth enforcement ‚Äî /api/auth/me should return 401
          echo "üîê Test 3: Auth Enforcement (/api/auth/me)"
          echo "--------------------------------------------"
          RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" "$BACKEND_URL/api/auth/me" || echo "FAILED")
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1 | cut -d: -f2)

          if [ "$HTTP_CODE" = "401" ]; then
            echo "‚úÖ Auth correctly enforced ‚Äî unauthenticated request rejected (HTTP 401)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "‚ùå Expected 401, got HTTP $HTTP_CODE"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          fi
          echo ""

          # Test 4: Protected endpoint ‚Äî /api/links should return 401
          echo "üîê Test 4: Protected Endpoint (/api/links)"
          echo "--------------------------------------------"
          RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" "$BACKEND_URL/api/links" || echo "FAILED")
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1 | cut -d: -f2)

          if [ "$HTTP_CODE" = "401" ]; then
            echo "‚úÖ Protected endpoint correctly enforced (HTTP 401)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "‚ùå Expected 401, got HTTP $HTTP_CODE"
            TESTS_FAILED=$((TESTS_FAILED + 1))
          fi
          echo ""

          # Summary
          echo "üéØ Smoke Tests Summary"
          echo "======================"
          echo "‚úÖ Passed: $TESTS_PASSED"
          echo "‚ùå Failed: $TESTS_FAILED"
          echo ""

          if [ $TESTS_FAILED -gt 0 ]; then
            echo "‚ùå Some smoke tests failed ‚Äî please investigate"
            exit 1
          else
            echo "‚úÖ All production smoke tests passed"
          fi

  notifications:
    name: Deployment Notifications
    runs-on: ubuntu-latest
    if: always()
    needs: [deploy-backend, deploy-frontend, smoke-tests]

    steps:
      - name: Post Success Notification
        if: needs.deploy-backend.result == 'success' && needs.deploy-frontend.result == 'success' && needs.smoke-tests.result == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const commit_sha = context.sha.substring(0, 7);
            const commit_url = `${context.payload.repository.html_url}/commit/${context.sha}`;

            github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `‚úÖ **Production Deployment Successful**\n\n` +
                    `**Commit**: [${commit_sha}](${commit_url})\n` +
                    `**Backend**: https://rush.mn\n` +
                    `**Frontend**: https://rushomon.cc\n` +
                    `**Time**: ${new Date().toISOString()}\n\n` +
                    `All smoke tests passed.`
            });

      - name: Post Failure Notification
        if: needs.deploy-backend.result == 'failure' || needs.deploy-frontend.result == 'failure' || needs.smoke-tests.result == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            const commit_sha = context.sha.substring(0, 7);
            const backend_status = '${{ needs.deploy-backend.result }}';
            const frontend_status = '${{ needs.deploy-frontend.result }}';
            const smoke_status = '${{ needs.smoke-tests.result }}';

            github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `‚ùå **Production Deployment Failed**\n\n` +
                    `**Commit**: ${commit_sha}\n` +
                    `**Backend**: ${backend_status}\n` +
                    `**Frontend**: ${frontend_status}\n` +
                    `**Smoke Tests**: ${smoke_status}\n\n` +
                    `**Action**: [View Details](${context.payload.repository.html_url}/actions/runs/${context.runId})\n\n` +
                    `Please review the logs and rollback if necessary.`
            });
